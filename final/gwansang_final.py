# -*- coding: utf-8 -*-
"""Gwansang_final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nEydnmbVxidtd4O-a3Vp8C_N3jrKsykr

# 환경설정
"""

!pip install mediapipe opencv-python

import mediapipe as mp
from mediapipe.tasks import python
from mediapipe.tasks.python import vision

# Commented out IPython magic to ensure Python compatibility.
# 1. SegFace 저장소 클론 및 이동
!git clone https://github.com/Kartik-3004/SegFace.git
# %cd SegFace

# 2. 필수 라이브러리 설치 (코랩 환경 최적화 버전)
!pip install -q timm==0.9.12 segmentation-models-pytorch albumentations python-dotenv huggingface_hub

import os
if not os.path.exists('face_landmarker.task'):
    !wget -q https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task
model_path = '/content/face_landmarker.task'

import os
from huggingface_hub import hf_hub_download

# 1. .env 경로 설정 파일 생성
root_path = "/content/SegFace"
with open(".env", "w") as f:
    f.write(f"ROOT_PATH={root_path}\n")
    f.write(f"DATA_PATH={root_path}/data\n")
    f.write(f"LOG_PATH={root_path}/logs\n")

# 2. 가중치(Weights) 다운로드
hf_hub_download(repo_id="kartiknarayan/SegFace",
                filename="convnext_celeba_512/model_299.pt",
                local_dir="./weights")

print("✅ 환경 설정 및 가중치 다운로드 완료!")

# Commented out IPython magic to ensure Python compatibility.
import torch
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import sys
import os

# 1. 경로 설정 및 모듈 임포트
# %cd /content/SegFace
if '/content/SegFace' not in sys.path:
    sys.path.append('/content/SegFace')

# 수정된 경로로 클래스 임포트
from network.models.segface_celeb import SegFaceCeleb

# 2. 설정
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model_path = "/content/SegFace/weights/convnext_celeba_512/model_299.pt"
image_path = "/content/mememe_fixed.jpg" # input 바꾸기
input_res = 512

# 3. 모델 초기화 및 가중치 로드
model = SegFaceCeleb(input_res, "convnext_base")

checkpoint = torch.load(model_path, map_location=device)

# 가중치 키 추출 (에러 메시지에 기반하여 state_dict_backbone 등을 확인)
if 'state_dict_backbone' in checkpoint:
    print("state_dict_backbone 키를 발견했습니다.")
    # 저장소의 특이한 구조에 맞춰 가중치를 결합해야 할 수도 있습니다.
    # 일단 가장 확률이 높은 모델 가중치 키를 시도합니다.
    pretrained_dict = checkpoint['state_dict_backbone']
else:
    # 일반적인 경우
    pretrained_dict = checkpoint.get('model_state_dict', checkpoint)

# 현재 모델의 state_dict 가져오기
model_dict = model.state_dict()

# 가중치 이름이 'backbone.'으로 시작하지 않는 경우를 대비해 필터링 (필요 시)
# 아래는 키 이름이 매칭되지 않을 때 강제로 로드하기 위한 설정입니다.
model.load_state_dict(pretrained_dict, strict=False)

model.to(device)
model.eval()
print("모델 로드 완료!")

"""# 실행부"""

import cv2
import numpy as np
import mediapipe as mp
from mediapipe.tasks import python
from mediapipe.tasks.python import vision
from google.colab.patches import cv2_imshow
from google.colab import files
import os
import math
import torch
from PIL import Image, ImageOps


class ComprehensiveFaceFortuneAI:
    def __init__(self, model, device, mp_model_path='face_landmarker.task'):
        # 1. SegFace / 기본 설정
        self.model = model
        self.device = device
        self.L_SKIN = 2  # SegFace 피부 클래스

        # 얼굴 통계 상수
        self.S = {
            "height_ratio": {"p10": 1.15, "p50": 1.190, "p90": 1.280},
            "upper_ratio":  {"mean": 0.689, "std": 0.021},   # forehead_w / face_w
            "lower_ratio":  {"mean": 0.88, "std": 0.015},   # jaw_w / face_w
            "bone_protrusion": {"mean": 0.148, "std": 0.025, "top20": 0.169},
            "cheek_hollow":    {"mean": 0.160, "std": 0.028, "top20": 0.184},
            "asymmetry_z": 0.05,
            "asymmetry_y": 15
        }
        self.THRESHOLDS = {
            'len': {'short': 1.45, 'long': 1.55},            # 눈 길이 대비 눈썹 길이
            'gap': {'narrow': 0.138, 'wide': 0.162},        # 눈-눈썹 거리 / 얼굴 높이
            'curve': {'straight': 60.0, 'arched': 62.0},    # 굴곡도
            'thick_ratio': {'thin': 0.075, 'thick': 0.095}  # 두께 / 얼굴 높이
        }
        self.STATS = {
            'ear': {'long': 3.15, 'round': 2.75},     # p80, p30
            'size': {'large': 0.220, 'small': 0.166}, # p80, p20
            'tail': {'up': 6.0, 'down': -2.0},       # 각도
            'pupil': {'high': 0.40, 'low': 0.47},     # 위치
            'lid': {'deep': 0.050}                    # 눈두덩이
        }
        self.STATS_nose = {
            'width':  {'v_small': 0.265, 'small': 0.288, 'large': 0.315, 'v_large': 0.322},
            'height': {'short': 0.263, 'long': 0.288},
            'nostril': {'hide': 0.225, 'show': 0.242},
            'bridge': {'curved': 171.0, 'straight': 178.0},
            'glabella': {'narrow': 0.15},
            'volume': {                    # ← 새로 추가
                'thin': 0.030,             # 메마른 기준
                'normal': 0.040,           # 적당한 기준
                'thick': 0.050             # 살찐 기준
            }
        }
        self.STATS_mouth = {
            'width':   {'small': 0.300, 'large': 0.427},
            'smile':   {'down': -0.005, 'up': 0.017},
            'thick':   {'thin': 0.074, 'thick': 0.095},
            'balance': {'lower_heavy': 0.48, 'upper_heavy': 0.69},
            'asym':    {'high': 0.05}
        }

        # 얼굴 윤곽/보조 인덱스
        self.FACE_OUTLINE = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ]
        self.KEY_POINTS = [10, 152, 234, 454, 103, 332, 58, 288]

        self.JAW_LEFT      = 132
        self.JAW_RIGHT     = 361
        self.CHIN          = 152
        self.JAW_L_CORNER  = 58
        self.JAW_R_CORNER  = 288
        self.CHIN_L        = 148
        self.CHIN_R        = 377

        # 2. MediaPipe FaceLandmarker 설정
        base_options = python.BaseOptions(model_asset_path=mp_model_path)
        options = vision.FaceLandmarkerOptions(
            base_options=base_options,
            running_mode=vision.RunningMode.IMAGE
        )
        self.detector = vision.FaceLandmarker.create_from_options(options)

    # ============== 공통 유틸 ==============
    @staticmethod
    def get_dist(p1, p2):
        return np.linalg.norm(p1 - p2)

    @staticmethod
    def get_dist2(p1, p2):
        return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)

    @staticmethod
    def angle_deg(a, b, c):
        """각 ABC(deg) : b가 꼭짓점"""
        ba = a - b
        bc = c - b
        denom = (np.linalg.norm(ba) * np.linalg.norm(bc)) + 1e-9
        cosv = np.dot(ba, bc) / denom
        cosv = np.clip(cosv, -1.0, 1.0)
        return float(np.degrees(np.arccos(cosv)))

    @staticmethod
    def zscore(x, mean, std):
        return (x - mean) / (std + 1e-9)

    @staticmethod
    def _append(report, text=""):
        report.append(text)

    def align_face(self, img_bgr, results):
        """10번과 152번 랜드마크를 기준으로 얼굴을 수직으로 회전시킵니다."""
        h, w, _ = img_bgr.shape
        lm = results.face_landmarks[0]

        # 1. 기준점 좌표 추출 (픽셀 단위)
        p10 = np.array([lm[10].x * w, lm[10].y * h])   # 이마 중앙 끝
        p152 = np.array([lm[152].x * w, lm[152].y * h]) # 턱 끝

        # 2. 기울기 계산 (dy, dx)
        dy = p152[1] - p10[1]
        dx = p152[0] - p10[0]

        # 3. 현재 각도 계산 (라디안 -> 도)
        # 수직선(90도)으로부터 얼마나 기울어졌는지 계산
        angle_rad = math.atan2(dy, dx)
        angle_deg = math.degrees(angle_rad)

        # 우리가 원하는 각도는 90도(수직)이므로, 회전해야 할 양은 (90 - 현재각도)
        rotation_angle = angle_deg - 90

        # 4. 회전 행렬 생성 (회전 중심은 얼굴 중앙인 1번 코끝 또는 두 점의 중점)
        center = tuple((p10 + p152) / 2)
        matrix = cv2.getRotationMatrix2D(center, rotation_angle, 1.0)

        # 5. 이미지 회전
        aligned_img = cv2.warpAffine(img_bgr, matrix, (w, h), flags=cv2.INTER_CUBIC)

        return aligned_img, rotation_angle

    # ============== 측정 메트릭 계산 ==============
    def calculate_brow_metrics(self, landmarks):
        """눈썹 관상 핵심 지표"""
        # 1. 눈 길이 (양쪽 평균)
        eye_len = (self.get_dist2(landmarks[33], landmarks[133]) +
                   self.get_dist2(landmarks[362], landmarks[263])) / 2

        # 2. 눈썹 길이
        brow_len = (self.get_dist2(landmarks[285], landmarks[300]) +
                    self.get_dist2(landmarks[55], landmarks[70])) / 2
        brow_len_ratio = brow_len / eye_len if eye_len > 0 else 0

        # 얼굴 높이
        face_h = self.get_dist2(landmarks[10], landmarks[152])

        # 3. 눈썹-눈 거리 비율
        gap_l = self.get_dist2(landmarks[334], landmarks[159])
        gap_r = self.get_dist2(landmarks[105], landmarks[386])
        brow_eye_gap_ratio = (gap_l + gap_r) / 2 / face_h

        # 4. 굴곡도
        brow_mid_y = (landmarks[334].y + landmarks[105].y) / 2
        brow_end_y = (landmarks[285].y + landmarks[300].y +
                      landmarks[55].y + landmarks[70].y) / 4
        curve_raw = abs(brow_end_y - brow_mid_y)
        curve_val = max(0, curve_raw/face_h * 1000)


        # 5. 두께 비율
        thick_l = self.get_dist2(landmarks[334], landmarks[293])
        thick_r = self.get_dist2(landmarks[105], landmarks[66])
        thick_avg = (thick_l + thick_r) / 2
        thick_ratio = thick_avg / face_h
        thick_ratio_scaled = thick_ratio * 1.2

        # 6. 눈썹 꼬리 각도
        dx = landmarks[70].x - landmarks[55].x
        dy = landmarks[70].y - landmarks[55].y
        tail_angle = math.degrees(math.atan2(dy, dx))

        return {
            'ratio': brow_len_ratio,
            'gap': brow_eye_gap_ratio,
            'curve': curve_val,
            'thick_ratio': thick_ratio_scaled,
            'angle': tail_angle,
        }

    def calculate_eye_metrics(self, landmarks):
        """눈 관상 핵심 지표"""
        l_w = self.get_dist2(landmarks[33], landmarks[133])
        l_h = self.get_dist2(landmarks[159], landmarks[145])
        r_w = self.get_dist2(landmarks[362], landmarks[263])
        r_h = self.get_dist2(landmarks[386], landmarks[374])

        eye_w = (l_w + r_w) / 2
        eye_h = (l_h + r_h) / 2

        face_w = self.get_dist2(landmarks[234], landmarks[454])
        face_h = self.get_dist2(landmarks[10], landmarks[152])

        ear = eye_w / eye_h if eye_h > 0 else 0
        size_ratio = eye_w / face_w if face_w > 0 else 0
        '''
        l_angle = math.degrees(math.atan2(
            landmarks[133].y - landmarks[33].y,
            landmarks[33].x - landmarks[133].x
        ))
        r_angle = math.degrees(math.atan2(
            landmarks[362].y - landmarks[263].y,
            landmarks[263].x - landmarks[362].x
        ))'''

        # 왼쪽 눈 (33: Outer, 133: Inner)
        dy_l = landmarks[133].y - landmarks[33].y
        dx_l = landmarks[133].x - landmarks[33].x
        l_angle = math.degrees(math.atan2(dy_l, dx_l))

        # 오른쪽 눈 (263: Outer, 362: Inner)
        dy_r = landmarks[362].y - landmarks[263].y
        dx_r = landmarks[263].x - landmarks[362].x # X는 Outer가 더 큼
        r_angle = math.degrees(math.atan2(dy_r, dx_r))

        tail_angle = (l_angle + r_angle) / 2

        p_y_l = (landmarks[468].y - landmarks[159].y) / (landmarks[145].y - landmarks[159].y)
        p_y_r = (landmarks[473].y - landmarks[386].y) / (landmarks[374].y - landmarks[386].y)
        pupil_y = (p_y_l + p_y_r) / 2

        asym_ratio = abs(l_w - r_w) / eye_w if eye_w > 0 else 0

        return {
            'ear': ear,
            'size': size_ratio,
            'angle': tail_angle,
            'pupil': pupil_y,
            'asym': asym_ratio
        }

    def calculate_nose_metrics(self, landmarks, W, H):
        """코 관상 핵심 지표"""
        pts = np.array([(l.x * W, l.y * H) for l in landmarks])

        face_w = np.linalg.norm(pts[234] - pts[454])
        face_h = np.linalg.norm(pts[10] - pts[152])

        nose_w = np.linalg.norm(pts[102] - pts[331])
        nose_h = np.linalg.norm(pts[168] - pts[1])

        nose_w_ratio = nose_w / face_w
        nose_h_ratio = nose_h / face_h

        alar_base_y = (pts[102][1] + pts[331][1]) / 2
        tip_y = pts[1][1]
        nostril_ratio = (face_h - tip_y) / face_h

        v1 = pts[168] - pts[6]
        v2 = pts[1] - pts[6]
        norm_v1 = np.linalg.norm(v1)
        norm_v2 = np.linalg.norm(v2)
        angle = math.degrees(
            math.acos(np.clip(np.dot(v1, v2) / (norm_v1 * norm_v2 + 1e-9), -1.0, 1.0))
        )

        glabella_w = np.linalg.norm(pts[55] - pts[285]) / face_w

        # 추가
        nose_mid_w = np.linalg.norm(pts[219] - pts[439])  # 중간 지점
        mid_ratio = nose_mid_w / nose_w if nose_w > 0 else 0

        # 코끝 살집 (tip 주변 깊이)
        # z 좌표로 볼륨 추정
        tip_z = landmarks[1].z
        bridge_z = landmarks[6].z
        volume_depth = abs(tip_z - bridge_z)

        return {
            'width': nose_w_ratio,
            'height': nose_h_ratio,
            'nostril': nostril_ratio,
            'angle': angle,
            'glabella': glabella_w,
            'mid_ratio': mid_ratio,
            'volume': volume_depth
        }

    def calculate_mouth_metrics(self, landmarks, w, h):
        """입 관상 핵심 지표"""
        pts = np.array([(l.x * w, l.y * h) for l in landmarks])

        mouth_w = np.linalg.norm(pts[61] - pts[291])
        face_w = np.linalg.norm(pts[234] - pts[454])
        width_ratio = mouth_w / face_w

        center_y = (pts[0][1] + pts[17][1]) / 2
        corner_y = (pts[61][1] + pts[291][1]) / 2
        face_h = np.linalg.norm(pts[10] - pts[152])
        smile_ratio = (center_y - corner_y) / face_h

        upper_thick = np.linalg.norm(pts[0] - pts[13])
        lower_thick = np.linalg.norm(pts[14] - pts[17])
        total_thick = upper_thick + lower_thick
        thick_ratio = total_thick / face_h

        balance_ratio = upper_thick / (total_thick + 1e-6)

        left_len = np.linalg.norm(pts[61] - pts[0])
        right_len = np.linalg.norm(pts[291] - pts[0])
        asym_ratio = abs(left_len - right_len) / (mouth_w + 1e-9)

        return {
            'width': width_ratio,
            'smile': smile_ratio,
            'thick': thick_ratio,
            'balance': balance_ratio,
            'asym': asym_ratio
        }

    def calculate_face_shape_metrics(self, landmarks, z, w, h):
        """얼굴형/삼정 공통으로 쓰는 기본 측정"""
        pts = np.array([(int(l.x * w), int(l.y * h)) for l in landmarks])

        face_h = self.get_dist(pts[10] - 10, pts[152])
        face_w = self.get_dist(pts[234], pts[454])
        forehead_w = self.get_dist(pts[103], pts[332])
        jaw_w = self.get_dist(pts[58], pts[288])

        h_ratio = face_h / (face_w + 1e-9)
        u_ratio = forehead_w / (face_w + 1e-9)
        l_ratio = jaw_w / (face_w + 1e-9)

        bone_protrusion = float(np.std([z[i] for i in [234, 454, 10, 152, 1]]))
        cheek_hollow = float(abs((z[234] + z[454]) / 2 - (z[123] + z[352]) / 2))

        bone_z = self.zscore(
            bone_protrusion,
            self.S["bone_protrusion"]["mean"],
            self.S["bone_protrusion"]["std"]
        )
        cheek_z = self.zscore(
            cheek_hollow,
            self.S["cheek_hollow"]["mean"],
            self.S["cheek_hollow"]["std"]
        )

        asymmetry_z = float(abs(z[234] - z[454]))
        asymmetry_y = float(abs(int(pts[58][1]) - int(pts[288][1])))

        # 턱 각도/뾰족함/광대
        jaw_angle_L = self.angle_deg(
            pts[self.JAW_LEFT], pts[self.JAW_L_CORNER], pts[self.CHIN]
        )
        jaw_angle_R = self.angle_deg(
            pts[self.JAW_RIGHT], pts[self.JAW_R_CORNER], pts[self.CHIN]
        )
        jaw_angle = (jaw_angle_L + jaw_angle_R) / 2.0

        chin_near_w = self.get_dist(pts[self.CHIN_L], pts[self.CHIN_R])
        chin_sharp = chin_near_w / (jaw_w + 1e-9)
        cheek_prom = (face_w - jaw_w) / (face_w + 1e-9)

        return {
            "pts": pts,
            "face_h": face_h,
            "face_w": face_w,
            "forehead_w": forehead_w,
            "jaw_w": jaw_w,
            "h_ratio": h_ratio,
            "u_ratio": u_ratio,
            "l_ratio": l_ratio,
            "bone_protrusion": bone_protrusion,
            "cheek_hollow": cheek_hollow,
            "bone_z": bone_z,
            "cheek_z": cheek_z,
            "asymmetry_z": asymmetry_z,
            "asymmetry_y": asymmetry_y,
            "jaw_angle": jaw_angle,
            "chin_sharp": chin_sharp,
            "cheek_prom": cheek_prom,
        }

    # ============== 관상 판정 로직 (기존 함수들 그대로) ==============

    def determine_book_type(self, m):
        # 1. 상태 플래그 정의
        is_very_long = m['ratio'] > 1.60
        is_long = m['ratio'] > 1.48
        is_short = m['ratio'] < self.THRESHOLDS['len']['short']

        is_high = m['gap'] > self.THRESHOLDS['gap']['wide']
        is_low = m['gap'] < self.THRESHOLDS['gap']['narrow']

        is_arched = m['curve'] > 61.0
        is_curved = m['curve'] > 60.5
        is_straight = m['curve'] < 60.0

        is_very_thick = m['thick_ratio'] > 0.11
        is_thick = m['thick_ratio'] > self.THRESHOLDS['thick_ratio']['thick']
        is_thin = m['thick_ratio'] < self.THRESHOLDS['thick_ratio']['thin']

        is_drooping = m['angle'] > 10
        is_rising = m['angle'] < -5

        # =========================================================
        # [판정 로직]
        # =========================================================

        # 1. [특수 흉격]
        if is_drooping and is_low:
            return "👹 귀미 (도깨비 눈썹)", "눈썹이 거칠고 아래로 처지며 눈을 누르는 형상입니다. 형제궁이 탁해 형제·친척과의 인연이 순탄치 않을 수 있고, 겉으로는 온화해 보여도 속 기운이 강하고 욕망이 깊은 편입니다. 감정 기복이 크고 판단이 감정에 흔들리기 쉬우므로 절제가 중요합니다. 눈썹의 윤기와 정리가 보완되면 흉의 강도는 완화됩니다."
        if is_drooping:
            return "📉 팔자미 (여덟 팔자)", "눈썹 꼬리가 아래로 벌어지며 팔자 형태를 이룹니다. 수명과 재물의 기운은 비교적 길게 이어지나, 형제궁과 처궁의 기운이 약해 외로움을 타기 쉽습니다. 감정이 깊고 속정이 많으나 표현이 서툴러 관계에서 오해가 생길 수 있습니다. 말년까지 기운은 유지되는 상입니다."
        if is_short and is_thin:
            return "🍂 소산미 (흩어진 눈썹)", "눈썹 숱이 적고 듬성듬성 흩어진 형상입니다. 기운이 모이지 않고 분산되는 상으로, 형제·친척과 각자 흩어져 지내기 쉽습니다. 재물의 흐름도 일정치 않아 실속을 챙기는 노력이 필요합니다. 다만 눈썹 결이 정리되고 윤택이 생기면 점차 안정됩니다."
        if is_low and is_very_thick and m['curve'] > 68:
            return "🕸️ 교가미 (엉킨 눈썹)", "눈썹 털이 엉키고 방향이 고르지 못해 질서가 없는 형상입니다. 형제궁의 혼탁을 의미하여 형제간 불화나 금전 문제로 얽힘이 생기기 쉽습니다. 성정이 급하고 충동이 앞설 수 있어 신중함이 필요합니다. 눈썹을 단정히 정리하면 기운이 한결 순화됩니다."

        # 2. [최상급 귀격]
        if is_very_long and is_very_thick:
            if is_rising or is_curved:
                return "🐉 용미 (용 눈썹)", "길고 두텁고 위로 기운이 살아 있는 용의 형상입니다. 형제궁이 맑고 넓어 형제·친척의 덕이 따르며, 총명과 위엄이 함께 갖추어진 귀격입니다. 기상이 크고 도량이 넓어 많은 사람을 포용하는 기운이 있습니다. 윤택이 유지되면 평생 명예가 따릅니다."
            else:
                return "🐯 호미 (범 눈썹)", "길고 두터우며 힘이 실린 범의 눈썹입니다. 담력과 결단력이 강하고 인정이 깊어 주변의 신망을 얻는 상입니다. 형제궁이 두텁고 재물의 기초 기운도 안정적입니다. 추진력이 좋으나 지나친 강함은 절제할 필요가 있습니다."
        # 3. [상급 귀격]
        # 곡선형
        if is_curved or is_arched:
            if is_thick:
                return "🕊️ 경청미/청수미", "길고 맑게 휘어진 단정한 눈썹입니다. 지성과 품위가 드러나며 형제궁이 안정되어 있습니다. 총명하고 명예의 기운이 따르며, 눈썹 결이 고우면 평판이 좋습니다. 지나치게 옅지만 않으면 길상입니다."
            if is_long:
                return "🌙 신월미 (초승달 눈썹)", "초승달처럼 부드럽게 휘고 길며 맑은 기색이 도는 상입니다. 총명하고 감정이 고상하며 형제간 우애가 깊습니다. 재물과 명예의 기운이 함께 따르는 귀한 눈썹으로, 결이 곱고 윤택할수록 길상이 강해집니다."
            return "🌿 유엽미 (버들잎 눈썹)", "버들잎처럼 가늘고 부드럽게 휘어진 눈썹입니다. 감성이 섬세하고 언변이 유연합니다. 형제궁은 무난하나 기운이 약하면 자식운이 늦어질 수 있습니다. 맑은 기색이 돌면 귀인의 도움이 따릅니다."

        # 직선형
        if is_straight or not is_curved:
            if is_thick and is_thick:
                return "🗡️ 검미 (칼 눈썹)", "곧고 선명하며 칼날처럼 정제된 눈썹입니다. 지적 능력이 뛰어나고 판단이 빠르며 권위가 서는 형상입니다. 형제궁이 단정하여 질서와 원칙을 중시합니다. 맑은 윤기가 동반되면 청귀한 기운이 오래갑니다."
            if is_long:
                return "➖ 일자미 (일자 눈썹)", "곧고 가지런한 일자형 눈썹입니다. 성정이 단정하고 원칙을 중시하며 삶이 비교적 안정적입니다. 형제궁은 무난하나 인연이 많다기보다는 소수와 깊은 관계를 맺는 형상입니다. 윤택이 있으면 부귀장수의 상입니다."
            return "🏹 전청후소미", "앞머리는 가지런하나 꼬리로 갈수록 흩어지는 형상입니다. 초년 기운은 맑으나 중년 이후 기운 관리가 중요합니다. 형제궁은 초반에 좋고 후반에 다소 소원해질 수 있습니다. 눈썹 꼬리를 단정히 관리하면 안정됩니다."

        # 3. [중급/특수]
        if is_arched and m['thick_ratio'] < 0.13:
            if is_short and is_thick:
                return "🦁 대단촉미 (사자/단촉)", "짧으나 굵고 힘이 모인 눈썹입니다. 기운이 응집되어 재물의 기초가 단단합니다. 형제궁은 강하나 다소 독선적으로 보일 수 있습니다. 말년으로 갈수록 안정감이 생기는 상입니다."

        return "🌧️ 소수추미/간단미", "눈썹이 가늘거나 중간이 끊긴 형상입니다. 형제궁의 인연이 약하고 스스로 힘으로 길을 개척해야 하는 상입니다. 재주는 있으나 기운이 끊기지 않도록 꾸준함이 필요합니다. 눈썹을 정갈히 다듬으면 흉의 기운이 완화됩니다."

    def determine_book_type2(self, m):
        is_very_long = m['ear'] > 3.50
        is_long = m['ear'] > self.STATS['ear']['long']

        is_round = m['ear'] < self.STATS['ear']['round']
        is_mid_shape = not is_long and not is_round         # 중간 형태

        is_large = m['size'] > self.STATS['size']['large']  # 큼
        is_small = m['size'] < self.STATS['size']['small']  # 작음
        is_mid_size = not is_large and not is_small         # 중간 크기

        is_up = m['angle'] > 12.0   # 올라감
        is_slight_up = m['angle'] > 6.0
        is_down = m['angle'] < -2.0   # 처짐
        is_straight = -2.0 <= m['angle'] <= 6.0

        # =========================================================
        # 1. [특수/흉격] 우선 판정 (특징이 강함)
        # =========================================================
        if m['asym'] > 0.15:
            return "🌗 음양안 (짝짝이)", "좌우 눈의 크기나 기세가 서로 달라 균형이 어긋난 형상입니다. 내면과 외면의 생각이 다를 수 있으며, 상황에 따라 태도를 달리하는 재치가 있습니다. 통찰력과 계산력이 뛰어나 권세를 잡을 기질은 있으나, 신(神)이 과도하게 날카로우면 인간관계의 신뢰를 잃기 쉽습니다. 마음을 곧게 쓰면 큰 그릇이 됩니다."
        if is_down and is_long:
            return "🐍 사안 (뱀 눈)", "눈매가 가늘고 아래로 흐르며 동자가 또렷한 형상입니다. 직관과 감각이 예리하고 지략이 뛰어나나, 기운이 차고 냉한 편이라 독기가 서릴 수 있습니다. 감정 표현이 절제되어 속을 드러내지 않는 타입이며, 신(神)을 맑게 유지하는 수양이 중요합니다."
        if is_down:
            return "🐎 마안 (말 눈)", "눈꼬리가 처지고 눈매가 길게 늘어진 형상입니다. 성실하고 부지런하나 늘 바쁘게 움직이는 기운이 강합니다. 기(氣)가 분산되기 쉬워 실속을 챙기는 힘을 기르는 것이 중요합니다. 눈빛에 맑은 광채가 돌면 흉의 강도는 줄어듭니다."
        if m['pupil'] < 0.38: # 동공이 매우 위로 붙음 (상백안 기질)
            return "🐒 후안 (원숭이)", "눈동자가 위로 붙고 움직임이 잦은 형상입니다. 재치와 순발력이 뛰어나며 상황 판단이 빠릅니다. 두뇌 회전이 빠른 대신 의심이 많고 마음이 쉽게 흔들릴 수 있습니다. 신(神)이 맑으면 부귀를 누릴 수 있는 재간형입니다."
        if m['pupil'] > 0.60 and m['lid'] > 0.06: # 동공이 아래로 (하백안) 혹은 흐릿
            return "🐟 어안 (물고기)", "눈망울이 다소 돌출되거나 물기 어린 듯한 형상입니다. 기운이 약해 보이거나 집중력이 분산되기 쉽습니다. 건강과 정서 안정에 신경 써야 하며, 눈빛이 맑아지면 삶의 흐름도 안정됩니다. 급한 결단은 피하는 것이 좋습니다."

        if is_small and is_round:
            return "🐻 웅목 (곰 눈)", "눈이 작고 둥글며 묵직한 인상을 줍니다. 성정은 우직하고 끈기가 있으나 융통성이 부족할 수 있습니다. 판단이 느린 대신 한 번 정한 길은 쉽게 바꾸지 않습니다. 신(神)을 밝게 유지하면 후반 운은 안정됩니다."
        if is_small and m['angle'] < 0:
            return "🐷 저안 (돼지)", "눈이 작고 흐릿하거나 탐욕이 서린 듯한 형상입니다. 욕심이 앞서면 판단이 흐려질 수 있습니다. 흑백이 분명해지고 광채가 살아나면 길흉은 완화됩니다. 베풀고 절제하는 삶이 관건입니다."

        # =========================================================
        # 2. [대길상/귀격] 판정 (조건 엄격)
        # =========================================================
        # 용안: 길고 + 크고 + 올라감 (가장 완벽)
        if is_large and is_long and is_slight_up:
            return "🐲 용안 (용)", "눈이 길고 적당히 크며 눈꼬리가 위로 힘 있게 뻗은 형상입니다. 흑백이 분명하고 광채가 살아 있으면 최고 귀격에 속합니다. 기상이 높고 포부가 크며, 정기와 신(神)이 충만합니다. 일생 명예와 권위를 얻을 수 있는 대길상입니다."

        # 봉안: 길고 + 크지 않더라도(적당) + 가늘게 찢어짐
        if is_very_long and (is_straight or is_slight_up):
            return "🦅 봉안 (봉황)", "가늘고 길게 뻗으면서 눈빛이 영롱한 형상입니다. 지혜와 통찰이 뛰어나며 스스로 공명을 이루는 기질입니다. 눈동자가 또렷하고 맑으면 학식과 명성이 따릅니다. 부드러움 속에 기개가 숨은 귀한 상입니다."
        if is_long and is_up and 0.42 < m['pupil'] < 0.48:
            return "🦅 봉안 (봉황)", "가늘고 길게 뻗으면서 눈빛이 영롱한 형상입니다. 지혜와 통찰이 뛰어나며 스스로 공명을 이루는 기질입니다. 눈동자가 또렷하고 맑으면 학식과 명성이 따릅니다. 부드러움 속에 기개가 숨은 귀한 상입니다."

        # 호안: 크고 + 둥글고 + 부리부리(약간 올라감 or 평평)
        if is_large and is_round and m['angle'] > -2:
            return "🐅 호안 (호랑이)", "눈이 크고 둥글며 기세가 강한 형상입니다. 강직하고 침착하며 위엄이 서립니다. 흑백이 선명하면 부귀의 기운이 길게 이어집니다. 기운이 과하면 독선으로 보일 수 있어 절제가 중요합니다."

        # 사자안: 크고 + 쌍꺼풀 짐 (호안과 유사하나 더 정적)
        if is_large and is_mid_shape:
             return "🦁 사자안 (사자)", "눈이 크고 당당하며 정적인 위엄이 있는 형상입니다. 결단력과 책임감이 강하며, 청렴한 기운이 서려 있습니다. 신(神)이 맑으면 존경받는 위치에 오르는 상입니다."

        # =========================================================
        # 3. [형상 기반 강제 매핑] (평범/중간 수치 처리)
        # =========================================================

        # [A] 둥근 계열 (Round)
        if is_round:
            if m['angle'] < 10.0:
                return "🐂 우안 (소 눈)", "눈이 둥글고 동자가 안정적으로 자리한 형상입니다. 성실하고 묵묵히 쌓아가는 기질로 복록이 끊이지 않는 상입니다. 기운이 안정되어 장수의 상으로도 봅니다."
            elif is_up:
                return "🐱 묘목 (고양이)", "둥글면서 눈꼬리가 살짝 올라간 형상입니다. 재주와 감각이 뛰어나고 사람을 다루는 능력이 있습니다. 눈빛이 지나치게 흐리지 않으면 말년이 편안한 상입니다."
            else: # 처지진 않았으나 각도가 낮음
                return "🐢 구안 (거북이)", "둥글고 수려하며 눈빛이 차분합니다. 느긋하고 정직한 성정으로 건강과 장수의 기운이 있습니다. 재물의 흐름도 비교적 안정적입니다."

        # [B] 긴 계열 (Long)
        if is_long:
            if m['pupil'] < 0.45:
                return "🦢 학안 (학)", "눈이 길고 맑으며 동자가 또렷한 형상입니다. 청렴하고 기개가 높으며 정신이 맑습니다. 명예와 학식의 기운이 따르는 귀격입니다."
            else:
                return "🐘 상안 (코끼리)", "가늘고 길며 상하에 잔잔한 주름이 있는 형상입니다. 인자하고 도량이 넓으며 평생 안정된 기운이 이어집니다. 장수와 복록의 상입니다."

        # [C] 중간 계열 (Mid - 평범한 눈을 대신하는 관상)
        # 통계적으로 가장 많이 떨어지는 구간
        if is_mid_shape and is_mid_size:
            if is_slight_up:
                return "🐦 작안 (까치)", "눈이 맑고 꼬리가 살짝 올라간 형상입니다. 선량하고 신의가 두텁습니다. 초년보다 중년 이후 기운이 살아나는 상입니다."
            else:
                return "🦢 안목 (기러기)", "흑백이 분명하고 균형이 잡힌 눈입니다. 정의감과 덕망이 있으며, 사람들의 신뢰를 얻는 형상입니다. 큰 기복 없이 이름을 남길 수 있는 상입니다."

        # 그 외 나머지 (작거나 애매한 경우)
        return "🦅 공작안 (공작)", "눈빛이 또렷하고 형상이 분명한 상입니다. 자존심과 품격이 있으며 청렴한 기운이 서려 있습니다. 다소 예민해 보일 수 있으나 광채가 살아 있으면 결국 명성을 얻는 상입니다."

    def determine_nose_type(self, m):
        # 임계값 매핑
        S = self.STATS_nose


        # 용비: 높고 길고 곧음
        if m['height'] > S['height']['long'] and m['angle'] > S['bridge']['straight'] and m.get('volume',0) > S['volume']['normal']:
            return "🐲 용비 (용 코)", "산근이 곧고 높게 솟으며 준두가 풍성한 이상적인 형상입니다. 재백궁이 충실하고 중년 운이 크게 열리는 대귀격입니다. 재물의 축적력과 명예가 함께 따르며, 기세가 곧고 당당합니다. 오악과 조화를 이루면 세상에 이름을 남길 상입니다."

        if m['width'] < S['width']['v_small'] and m.get('volume',0) < S['volume']['thin']:
            return "🦴 노척비 (메마른 코)", "코에 살이 부족하고 뼈가 도드라진 형상입니다. 재물의 축적력보다는 소모가 빠른 구조입니다. 초년·중년의 기복이 생기기 쉬우므로 기반을 단단히 다지는 노력이 필요합니다."


        # ---------------------------------------------------------
        # 1. 흉상(Negative) 우선 체크
        # ---------------------------------------------------------
        if m['angle'] < S['bridge']['curved']:
            return "🦅 웅취비 (매부리코)", "콧등이 솟고 끝이 안으로 굽은 형상입니다. 재물의 흐름이 곧지 못하고 중간에 굴곡이 생기기 쉬운 상입니다. 성정이 예민하고 계산이 빠르나, 지나치면 타인과의 신뢰에 금이 갈 수 있습니다. 재물을 다루는 데 있어 투명함과 절제가 중요합니다."

        # 콧구멍 노출 (원본 로직: 수치가 높으면 노출) ->
        # *수정*: 여기서는 m['nostril'] 계산식이 바뀌었으므로 직관적으로 '코가 짧고(height short) 각도가 낮으면' 노출로 간주
        is_exposed = m['height'] < S['height']['short'] and m['angle'] < 175

        if is_exposed:
            if m['height'] > S['height']['long']: # 길면서 노출? (모순되지만 원본 로직 존중)
                 return "🌬️ 노조비 (드러난 코)", "코는 길고 높으나 콧구멍이 드러나는 형상입니다. 들어오는 재물에 비해 지출이 빠를 수 있어 재물의 저장력이 약해지기 쉽습니다. 외형은 좋아 보이나 내실 관리가 관건입니다. 절제와 계획성이 보완되면 기운이 안정됩니다."
            else:
                 return "🐕 구비 (개 코)", "콧등 뼈가 도드라지고 콧구멍이 보이는 형상입니다. 재백궁이 단단히 잠기지 못해 재물이 모였다가 흩어지기 쉬운 상입니다. 성정은 솔직하나 다소 거칠 수 있어 재물 관리에 신중함이 필요합니다."

        if m['width'] < S['width']['v_small'] and m['angle'] < 175:
            return "🔪 검봉비 (칼등 코)", "콧등이 칼날처럼 날카롭고 살집이 부족한 형상입니다. 재물의 기운이 메마르기 쉬우며 고독한 기질이 따를 수 있습니다. 지나친 강직함을 누그러뜨리고 온기를 더하면 운세의 흐름이 완화됩니다."


        # ---------------------------------------------------------
        # 2. 길상(Positive) 체크
        # ---------------------------------------------------------

        # 호비: 매우 크고 콧구멍 안 보임
        if m['width'] > S['width']['v_large'] and not is_exposed:
            return "🐅 호비 (호랑이 코)", "코가 둥글고 두터우며 콧구멍이 보이지 않는 안정된 형상입니다. 재물의 저장력이 강하고 일생 부귀의 기운이 이어집니다. 배포가 크고 기상이 당당하여 재물과 사람을 함께 얻는 상입니다."

        # 우비: 크고 높음
        if m['width'] > S['width']['large'] and m['height'] > 0.27:
            return "🐂 우비 (소 코)", "코가 크고 준두가 풍만하며 전체 윤곽이 힘 있게 자리한 형상입니다. 재물의 기초가 단단하고 축적 능력이 뛰어납니다. 성실하게 쌓아 큰 부를 이루는 상으로, 중년 이후 더욱 안정됩니다."

        # 현담비: 각도 좋고 콧구멍 숨김 (쓸개 모양)
        if m['angle'] > 176 and not is_exposed and m.get('mid_ratio',1.0) < 0.75:
            return "💊 현담비 (쓸개 코)", "산근이 인당까지 곧게 뻗어 기세가 단단한 형상입니다. 지략과 결단력이 뛰어나며 재물과 명예를 함께 얻는 귀격입니다. 중년 이후 사회적 위상이 상승하는 구조입니다."

        # 절통비/성낭비: 곧게 뻗음
        if m['angle'] > S['bridge']['straight'] and m['height'] > 0.26 and 0.70 <= m.get('mid_ratio',1.0) <= 0.90:
            if 0.26 <= m['width'] <= 0.32:
                if m['width'] >= 0.29:
                    return "🎋 절통비 (대나무 코)", "콧대가 곧고 가지런하며 통처럼 단정한 형상입니다. 재물의 흐름이 막힘없이 이어지고 평생 재운이 안정적입니다. 공명과 재복이 함께 따르는 길상입니다."
                else:
                    return "💰 성낭비 (주머니 코)", "둥근 주머니를 반으로 쪼갠 듯 곧고 풍성한 형상입니다. 재물을 담는 그릇이 크며 특히 중년 이후 큰 재복이 따릅니다. 윤기가 돌수록 길상이 강해집니다."
        elif m['angle'] >= S['bridge']['straight']:
            if m['width'] < 0.28:
                if m['height'] > 0.27:
                    return "🦌 장비 (노루 코)", "콧대가 작고 코끝이 뾰족한 형상입니다. 재물의 축적력이 크지 않으며 성정이 예민하고 의심이 많을 수 있습니다. 안정적인 환경에서 기운을 보완하는 것이 좋습니다."
                else:
                    return "🐟 즉어비 (물고기 코)", "콧대가 가늘고 준두가 아래로 처진 형상입니다. 재물의 기운이 약하고 친족의 덕이 희박할 수 있습니다. 기초 체력을 기르고 재정 관리에 힘쓰면 흉의 강도는 완화됩니다."
            elif m['width'] > 0.33:
                return "🐂 우비 (소 코)", "코가 크고 준두가 풍만하며 전체 윤곽이 힘 있게 자리한 형상입니다. 재물의 기초가 단단하고 축적 능력이 뛰어납니다. 성실하게 쌓아 큰 부를 이루는 상으로, 중년 이후 더욱 안정됩니다."

        # ---------------------------------------------------------
        # 3. 특수/일반형 매핑
        # ---------------------------------------------------------
        if m['width'] > S['width']['large']:
            return "🦁 사자비 (사자 코)", "산근은 다소 낮으나 준두와 난대가 풍대하여 힘이 모인 형상입니다. 배포와 추진력이 좋으며 재물을 다루는 통이 큽니다. 다만 세밀한 관리가 부족하면 일부 재물이 새어 나갈 수 있습니다."

        if m['height'] > 0.28 and m['glabella'] < S['glabella']['narrow']:
            return "🦍 성비 (성성이 코)", "콧대가 우뚝 솟고 기세가 강한 형상입니다. 의리와 덕망을 중시하며 큰 틀에서 재물을 다루는 상입니다. 미간이 좁으면 성정이 급해질 수 있으나, 기개와 명예의 기운이 강합니다."

        if m['width'] < S['width']['small']:
            if m['height'] < S['height']['short']:
                return "🐟 즉어비 (물고기 코)", "콧대가 가늘고 준두가 아래로 처진 형상입니다. 재물의 기운이 약하고 친족의 덕이 희박할 수 있습니다. 기초 체력을 기르고 재정 관리에 힘쓰면 흉의 강도는 완화됩니다."
            else:
                return "🦌 장비 (노루 코)", "콧대가 작고 코끝이 뾰족한 형상입니다. 재물의 축적력이 크지 않으며 성정이 예민하고 의심이 많을 수 있습니다. 안정적인 환경에서 기운을 보완하는 것이 좋습니다."

        if m['angle'] < 174:
            return "🐒 원비 (원숭이 코)", "콧대가 낮고 콧구멍이 작으며 전체적으로 왜소한 형상입니다. 눈치와 재간은 빠르나 재물의 저장력은 약한 편입니다. 기초를 단단히 다지면 점차 안정됩니다."

        # 그 외
        if m['width'] > 0.30:
            return "🧄 산비 (마늘 코)", "콧대는 평평하나 준두가 마늘처럼 둥글고 풍성한 형상입니다. 초년에는 평범하나 중년 이후 재물의 기운이 점차 쌓입니다. 끈기와 인내가 복을 부르는 상입니다."

        return "🐏 호양비 (양 코)", "코가 풍성하고 가지런하며 뿌리가 깊은 형상입니다. 성품이 너그럽고 재물의 흐름이 비교적 안정적입니다. 자손과 가계의 번성이 따르는 온화한 길상입니다."

    def determine_mouth_type(self, m):

        candidates = []

        # =========================================================
        # [Text DB] 관상 해설 데이터베이스 (풍성한 문장)
        # =========================================================
        DESCRIPTIONS = {
            # 흉격 (Negative)
            "취화구": "입을 다물지 못하고 마치 불을 끄듯 뾰족하게 모인 형상입니다. 마음속에 담아두지 못하고 말을 내뱉어 기운이 새어나가기 쉽습니다. 말수를 줄이고 입을 굳게 다무는 습관을 들이면 새는 복을 막을 수 있습니다.",
            "저구": "윗입술이 유독 두껍거나 돌출되어 아랫입술을 덮는 형상입니다. 욕망이 강하고 현실적인 이익을 좇는 성향이 뚜렷합니다. 때로는 독선적으로 비칠 수 있으니, 타인을 배려하는 마음을 기르면 흉이 길로 바뀝니다.",
            "복선구": "입술에 주름이 많고 비대칭이며, 마치 배가 뒤집힌 듯 입꼬리가 처진 상입니다. 내면의 고독감이 깊고 인간관계의 허무함을 느끼기 쉽습니다. 억지로라도 입꼬리를 올리는 훈련을 통해 말년의 고독을 피해야 합니다.",
            "점어구": "입은 크지만 힘없이 축 처져 메기 입과 같은 형상입니다. 큰 그릇을 가졌으나 기운이 담기지 못하고 흘러내리는 격입니다. 시작은 창대하나 끝맺음이 약할 수 있으니, 끈기를 가지고 마무리에 집중하면 대기만성할 수 있습니다.",
            "죽어구": "입술이 얇고 기운이 없으며 처져 있는 붕어 입 형상입니다. 매사에 불평이 많거나 건강이 약해질 수 있습니다. 긍정적인 언어를 사용하고 체력을 기르면 운세가 호전됩니다.",
            "추문구": "입술 위아래에 잔주름이 많고 입꼬리가 처진 형상입니다. 재물이 모이기보다 흩어지기 쉬우며, 자수성가해야 하는 고단함이 있습니다. 저축을 생활화하고 안정을 추구하는 것이 좋습니다.",
            "양구": "입이 작고 입술이 매우 얇은 형상입니다. 빈틈이 없고 야무지지만, 다소 냉정하거나 인색하다는 평을 들을 수 있습니다. 베푸는 마음을 가지면 덕이 쌓여 복이 돌아옵니다.",

            # 길격 (Positive)
            "사자구": "입이 크고 두터우며 입꼬리가 위를 향해 위엄이 넘치는 '사자 입'입니다. 천하를 호령할 리더의 상으로, 부와 명예가 저절로 따릅니다. 스케일이 크고 배포가 있어 어떤 조직에서든 우두머리가 될 대귀격입니다.",
            "용구": "입술이 매우 두툼하고 풍만하여 압도적인 에너지를 뿜어내는 '용 입'입니다. 평생 의식주 걱정이 없으며, 사업을 하거나 사람을 거느리는 위치에서 능력을 발휘합니다. 강인한 체력과 추진력이 돋보입니다.",
            "호구": "입의 너비가 얼굴을 가득 채울 만큼 시원하고 큰 '호랑이 입'입니다. 작은 일에 연연하지 않는 대범함이 있으며, 한 번 물면 놓지 않는 집념으로 큰 부를 축적합니다. 활동적인 분야에서 크게 성공할 상입니다.",
            "앙월구": "입꼬리가 초승달처럼 아름답게 올라간 '반달 입'입니다. 감수성이 풍부하고 재능이 뛰어나며, 사람들에게 사랑받는 도화(桃花)의 기운이 있습니다. 문학, 예술, 인기 관련 분야에서 이름을 떨칠 귀한 상입니다.",
            "방구": "입술의 선이 반듯하고 붉으며, 다물었을 때 네모진 '방정한 입'입니다. 신의가 두텁고 원칙을 중시하여 타인의 신뢰를 한 몸에 받습니다. 공직이나 학계처럼 명예가 중요한 곳에서 꾸준히 승승장구할 모범적인 길상입니다.",
            "앵도구": "입은 작지만 앵두처럼 붉고 도톰하여 기운이 응집된 '앵두 입'입니다. 화려한 언변과 매력으로 주변의 인기를 독차지합니다. 겉보기엔 작아도 실속을 챙기는 능력이 탁월하여 알짜배기 부자가 되는 상입니다.",
            "유구": "특별히 모나지 않고 두툼하며 단정한 '소 입'입니다. 우직하고 성실한 성품으로 묵묵히 재물을 모아 결국 큰 부를 이룹니다. 말수가 적어도 무게감이 있어 아랫사람의 존경을 받습니다.",
            "만궁구": "입술 선이 활처럼 매끄러운 곡선(또는 직선)을 그리며 단정한 '활 입'입니다. 과욕을 부리지 않고 자신의 분수를 지키며 평온한 삶을 누립니다. 대인관계가 원만하고 장수하는 맑은 상입니다.",
            "후구": "입술에 약간의 주름이나 굴곡이 있으나 식복이 좋은 '잔나비(원숭이) 입'입니다. 재주가 많고 임기응변에 능하여 어떤 어려움도 지혜롭게 헤쳐나갑니다. 중년 이후 운세가 더욱 좋아집니다."
        }

        # =========================================================
        # [1] 기준값 설정 (알고리즘 유지)
        # =========================================================
        T_HUGE, T_THICK, T_MID = 0.110, 0.085, 0.070
        W_HUGE, W_LARGE = 0.400, 0.340
        W_NORMAL = 0.290
        W_SMALL  = 0.325
        S_HIGH, S_MID = 0.035, 0.020
        S_LOW = -0.002
        B_MIN, B_MAX = 0.44, 0.56

        # =========================================================
        # [2] 흉격 (Negative) - 점수: 85~100
        # =========================================================
        if m['width'] < 0.28 and m['thick'] > 0.13:
            candidates.append((100, "6. 불 부는 입 (취화구)", DESCRIPTIONS["취화구"]))

        if m['balance'] > 0.70:
            candidates.append((95, "5. 돼지 입 (저구)", DESCRIPTIONS["저구"]))

        if m['asym'] > 0.08 and m['smile'] < 0:
            candidates.append((92, "16. 복선구 (엎어진 배)", DESCRIPTIONS["복선구"]))

        if m['width'] > W_LARGE and m['smile'] < S_LOW:
            candidates.append((90, "14. 메기 입 (점어구)", DESCRIPTIONS["점어구"]))

        if m['thick'] < 0.055 and m['smile'] < S_LOW:
            candidates.append((88, "15. 붕어 입 (죽어구)", DESCRIPTIONS["죽어구"]))

        if m['smile'] < S_LOW:
            candidates.append((85, "7. 주름잡힌 입 (추문구)", DESCRIPTIONS["추문구"]))

        if m['width'] < 0.28 and m['thick'] < 0.060:
            candidates.append((80, "12. 양 입 (양구)", DESCRIPTIONS["양구"]))


        # =========================================================
        # [3] 길격 (Positive) - 점수: 60~90
        # =========================================================
        if m['width'] > W_LARGE and m['thick'] > T_THICK and m['smile'] > 0:
            candidates.append((90, "1. 넉 사자 입 (사자구)", DESCRIPTIONS["사자구"]))

        if m['thick'] > T_HUGE:
            candidates.append((88, "10. 용 입 (용구)", DESCRIPTIONS["용구"]))

        if m['width'] > W_HUGE:
            candidates.append((88, "11. 호랑이 입 (호구)", DESCRIPTIONS["호구"]))

        if m['smile'] > S_HIGH:
            candidates.append((80, "3. 반달 입 (앙월구)", DESCRIPTIONS["앙월구"]))

        # [방정한 입]
        is_straight = (-0.01 <= m['smile'] <= S_MID)
        if is_straight and (m['thick'] >= T_THICK) and (B_MIN <= m['balance'] <= B_MAX) and (m['width'] > W_NORMAL):
            candidates.append((82, "2. 방정한 입 (방구)", DESCRIPTIONS["방구"]))


        # =========================================================
        # [4] 일반/소형격 - 점수: 50~70
        # =========================================================
        if m['width'] <= W_SMALL and m['thick'] >= T_MID:
            candidates.append((70, "8. 앵두 입 (앵도구)", DESCRIPTIONS["앵도구"]))

        if m['thick'] >= T_MID:
            candidates.append((60, "9. 소 입 (유구)", DESCRIPTIONS["유구"]))

        if is_straight:
             candidates.append((50, "4. 활 입 (만궁구)", DESCRIPTIONS["만궁구"]))

        if m['asym'] > 0.04:
            candidates.append((55, "13. 잔나비 입 (후구)", DESCRIPTIONS["후구"]))


        # =========================================================
        # [5] 최종 선발
        # =========================================================
        if not candidates:
            return "4. 활 입 (만궁구)", DESCRIPTIONS["만궁구"]

        candidates.sort(key=lambda x: x[0], reverse=True)



        return candidates[0][1], candidates[0][2]


    # ============== 세부 분석 메서드 ==============
    def analyze_samjeong(self, seg_hairline_y, pts, report):
        """SegFace + MediaPipe 결합 삼정 분석"""
        MEAN_S, MEAN_J, MEAN_H = 0.294, 0.222, 0.484  # 필요시 사용

        # MediaPipe 이마 기준선 (landmark 10)
        mp_forehead_y = pts[10][1]
        # SegFace 발제선이 없거나(mp 실패) / 이마보다 더 아래(y가 큼)면 무시하고 MediaPipe 기준 사용
        if (seg_hairline_y is None) or (seg_hairline_y > mp_forehead_y):
            actual_top_y = mp_forehead_y
        else:
            actual_top_y = seg_hairline_y


        sang_len = self.get_dist(
            np.array([pts[9][0], actual_top_y]), pts[9]
        )
        jung_len = self.get_dist(pts[9], pts[2])
        ha_len = self.get_dist(pts[2], pts[152])

        total_len = sang_len + jung_len + ha_len
        r_sang = sang_len / total_len
        r_jung = jung_len / total_len
        r_ha = ha_len / total_len

        balance_score = np.std([r_sang, r_jung, r_ha])

        self._append(report, "=" * 60)
        self._append(report, "[ ⚖️ 삼정(三停) 분석 ]")
        self._append(report, "=" * 60)
        # self._append(
        #     report,
        #     f"- 산출 비율(이마-코-턱): {r_sang:.2f} : {r_jung:.2f} : {r_ha:.2f}"
        # )

        if balance_score < 0.10:
            self._append(
                report,
                "✅ [삼정평등] 삼정의 비율이 매우 안정적이며 균형 잡힌 길상입니다."
            )
        else:
        # 어떤 정(停)에 기운이 집중됐는지 판정
            ratios = {
                "상정(이마)": r_sang,
                "중정(코)": r_jung,
                "하정(턱)": r_ha
            }
            max_region = max(ratios, key=ratios.get)

            if "상정" in max_region:
                focus_msg = "초년·청년기(상정) 쪽 비율이 커서, 젊을 때의 운과 시작 운이 강한 형입니다."
            elif "중정" in max_region:
                focus_msg = "중년기(중정) 비율이 커서, 30~50대 사이 활동기 운이 특히 강조된 형입니다."
            else:
                focus_msg = "말년·노년기(하정) 비율이 커서, 후반부 인생에서 운이 트이거나 기운이 모이는 형입니다."

            self._append(
                report,
                f"⚠️ [비율 특이] 세 구간이 고르게 나뉘지 않고 {max_region}에 기운이 몰려 있는 상입니다."
            )
            self._append(report, f"   → 해석: {focus_msg}")


    # =============================================
    #                   얼굴형
    # =============================================


    def analyze_face_shape(self, face_info, report):
        """안면 13대 형상 판독"""
        h_ratio = face_info["h_ratio"]
        u_ratio = face_info["u_ratio"]
        l_ratio = face_info["l_ratio"]
        bone_protrusion = face_info["bone_protrusion"]
        cheek_hollow = face_info["cheek_hollow"]
        bone_z = face_info["bone_z"]
        cheek_z = face_info["cheek_z"]
        asymmetry_z = face_info["asymmetry_z"]
        asymmetry_y = face_info["asymmetry_y"]
        jaw_angle = face_info["jaw_angle"]
        chin_sharp = face_info["chin_sharp"]
        cheek_prom = face_info["cheek_prom"]

        res = "일반형"
        print(h_ratio)
        print(u_ratio)
        print(l_ratio)
        print(jaw_angle)
        print(chin_sharp)
        print(cheek_prom)
        self._append(report, "\n" + "=" * 60)
        self._append(report, "[ 👤 안면 13대 형상 판독 ]")
        self._append(report, "=" * 60)

        # (1) 1차 분류: 세로 비율
        if h_ratio < self.S["height_ratio"]["p10"]:
            if l_ratio > self.S["lower_ratio"]["mean"]:
                if jaw_angle < 120:
                    res = ("입구(口)/전(田)자형: 얼굴 윤곽이 네모지고 사각이 분명한 장부형이다. 골격과 근육이 단단하고 기운이 외부로 강하게 발산되는 형상으로, 성정이 빠르고 결단력이 있으며 행동이 앞서는 경향이 뚜렷하다. 일에 임하면 망설임이 적고, 어려움이 와도 몸으로 부딪혀 돌파하려는 기질이 강하다. 다만 성급함과 거친 표현이 동반되기 쉬워 완급 조절이 중요하며, 얼굴 살집과 윤택함이 받쳐주지 않으면 기복이 커질 수 있다.")

                else:
                    res = "정원형(正圓形): 얼굴 둘레가 둥글고 O자에 가까운 호인형으로, 살집이 풍부하고 인상이 부드럽다. 기본 성정은 낙천적이고 명랑하여 사람들과 쉽게 어울리며 분위기를 밝게 만드는 기운이 있다. 다만 형상이 지나치게 원만하면 주관과 중심이 약해 환경과 주변 사람의 영향을 크게 받는 편이다. 흐름을 타는 삶이 되기 쉬워 스스로 기준을 세우는 것이 중요하다."

            else:
                res = "삼각형: 상부는 좁고 하부로 갈수록 넓어지는 형으로, 턱과 하관의 기운이 강하다. 생활력과 생존력이 뛰어나며, 한 번 마음먹은 일은 끝까지 밀어붙이려는 고집이 있다. 신체적 기운이 강하고 현실 감각이 발달했으나, 융통성은 다소 부족할 수 있다. 얼굴 균형이 잘 맞으면 꾸준히 버티는 힘이 장점으로 작용한다."

        elif h_ratio > self.S["height_ratio"]["p90"]:
            if u_ratio > 0.74:
                if l_ratio > self.S["lower_ratio"]["mean"]:
                    if jaw_angle < 130:
                        res = ("입구(口)/전(田)자형: 얼굴 윤곽이 네모지고 사각이 분명한 장부형이다. 골격과 근육이 단단하고 기운이 외부로 강하게 발산되는 형상으로, 성정이 빠르고 결단력이 있으며 행동이 앞서는 경향이 뚜렷하다. 일에 임하면 망설임이 적고, 어려움이 와도 몸으로 부딪혀 돌파하려는 기질이 강하다. 다만 성급함과 거친 표현이 동반되기 쉬워 완급 조절이 중요하며, 얼굴 살집과 윤택함이 받쳐주지 않으면 기복이 커질 수 있다.")

                    else:
                        res = "동(同)자형: 얼굴이 약간 길면서도 네모진 형으로, 골격과 살이 조화를 이루면 안정감이 매우 크다. 성정이 온화하면서도 중심이 잡혀 있어 강함과 부드러움을 함께 지닌 상이다. 처사가 공정하고 치우침이 적으며, 한쪽으로 과하지 않은 균형형 인물이다. 얼굴 전체의 윤택함이 유지되면 삶의 흐름이 비교적 고르게 이어지는 형상이다."
                else:
                    res = "갑(甲)자형: 이마와 상부는 넓고 안정되어 있으나 턱이 뾰족하게 빠진 형이다. 생각과 이상은 크지만 감정과 행동의 기복이 함께 나타나는 상으로, 일정한 리듬을 유지하는 것이 쉽지 않다. 맑고 청수한 기운이 있으면 중년 이후 안정으로 흐르며, 그렇지 않으면 초반의 기운을 지키기 어렵다."
            elif l_ratio > self.S["lower_ratio"]["mean"]:
                res = "동(同)자형: 얼굴이 약간 길면서도 네모진 형으로, 골격과 살이 조화를 이루면 안정감이 매우 크다. 성정이 온화하면서도 중심이 잡혀 있어 강함과 부드러움을 함께 지닌 상이다. 처사가 공정하고 치우침이 적으며, 한쪽으로 과하지 않은 균형형 인물이다. 얼굴 전체의 윤택함이 유지되면 삶의 흐름이 비교적 고르게 이어지는 형상이다."
            elif l_ratio < 0.85:
                res = "목(目)자형: 얼굴이 길고 좁으며 네 귀가 각져 보이는 형이다. 두뇌 회전이 빠르고 감각이 예민하여 작은 변화도 놓치지 않는다. 대신 신경이 섬세하고 감정 기복이 생기기 쉬워 대인 관계에서 피로를 느끼는 경우가 많다. 한 가지에 깊이 몰입하는 성향이 강해 집중력은 뛰어나나, 마음의 여유를 기르는 것이 관건이다."

            else:
                res = "장원형(長圓形): 계란형에 가까운 얼굴로, 전체 윤곽이 매끄럽고 정제된 인상을 준다. 성정이 침착하고 이성적이며 감정 표현이 절제되어 있다. 스스로를 잘 지키는 타입으로, 소란한 상황에서도 중심을 잃지 않는다. 외형이 단정할수록 신중함이 강해지며, 지나치면 냉정해 보일 수 있다."

        else:
            upper_hi = self.S["upper_ratio"]["mean"] + self.S["upper_ratio"]["std"]
            upper_lo = self.S["upper_ratio"]["mean"] - self.S["upper_ratio"]["std"]
            lower_hi = self.S["lower_ratio"]["mean"] + self.S["lower_ratio"]["std"]
            lower_lo = self.S["lower_ratio"]["mean"] - self.S["lower_ratio"]["std"]

            if h_ratio > 1.15 and 0.80 <= l_ratio <= 0.90:
                    res = ("장원형(長圓形): 계란형에 가까운 얼굴로, 전체 윤곽이 매끄럽고 정제된 인상을 준다. "
                        "성정이 침착하고 이성적이며 감정 표현이 절제되어 있다. "
                        "스스로를 잘 지키는 타입으로, 소란한 상황에서도 중심을 잃지 않는다. "
                        "외형이 단정할수록 신중함이 강해지며, 지나치면 냉정해 보일 수 있다.")
            elif (u_ratio > upper_hi) and (l_ratio < lower_lo):
                if chin_sharp < 0.55:
                    res = "역삼각형: 이마는 넓고 하관으로 갈수록 급격히 좁아지는 형으로, 두뇌와 감각의 기운이 상부에 집중된 상이다. 관찰력과 이해력이 뛰어나고 머리가 빠르나, 성질이 급하고 예민한 면이 있다. 생각이 앞서고 감정 소모가 잦아 스스로를 소진시키기 쉬운 형상이다."

                else:
                    res = "갑(甲)자형: 이마와 상부는 넓고 안정되어 있으나 턱이 뾰족하게 빠진 형이다. 생각과 이상은 크지만 감정과 행동의 기복이 함께 나타나는 상으로, 일정한 리듬을 유지하는 것이 쉽지 않다. 맑고 청수한 기운이 있으면 중년 이후 안정으로 흐르며, 그렇지 않으면 초반의 기운을 지키기 어렵다."

            elif (u_ratio < upper_lo) and (l_ratio > lower_hi):
                res = "유(由)자형: 이마는 좁고 하관이 넓고 풍부한 형으로, 위보다 아래에 힘이 실린 구조다. 초반에는 기반이 약해 보이나 시간이 흐를수록 축적되는 기운이 강하다. 인내와 현실 적응력이 뛰어나며, 얼굴 하부의 살과 윤기가 살아 있을수록 후반 운의 안정성이 커진다."

            elif (u_ratio < upper_lo) and (l_ratio < lower_lo):
                if cheek_prom > 0.10:
                    res = "신(申)자형: 이마와 턱은 좁은 편이나 관골이 유독 발달한 다이아몬드형이다. 의지가 강하고 고집이 있으며, 한 번 정한 방향은 쉽게 꺾지 않는다. 내면에 독한 기운이 있어 스스로를 몰아붙이는 경향이 있으나, 중반 이후 자립의 힘이 강해진다. 말년에는 기복 관리가 중요하다."

                else:
                    res = "일반형(혼합): 특정 형상이 과하게 치우치지 않고 여러 기운이 고르게 섞인 균형형 얼굴이다. 극단적인 기복이 적고 환경 적응력이 뛰어나며, 상황에 따라 유연하게 변화를 받아들이는 장점이 있다. 한쪽으로 강하게 치닫지 않기 때문에 삶의 흐름이 비교적 안정적이며, 얼굴의 세부 오관이 조화를 이루면 점진적으로 상승하는 형상이다. 전체 윤곽의 안정감이 곧 장기적인 지속력을 의미한다."
            else:
                res = "장원형(長圓形): 계란형에 가까운 얼굴로, 전체 윤곽이 매끄럽고 정제된 인상을 준다. 성정이 침착하고 이성적이며 감정 표현이 절제되어 있다. 스스로를 잘 지키는 타입으로, 소란한 상황에서도 중심을 잃지 않는다. 외형이 단정할수록 신중함이 강해지며, 지나치면 냉정해 보일 수 있다."

        # 특수형 (왕/용)
        is_wang = (
            (bone_protrusion > self.S["bone_protrusion"]["top20"] and
             cheek_hollow > self.S["cheek_hollow"]["top20"])
            or (bone_z > 0.85 and cheek_z > 0.85)
        )
        if is_wang:
            res = "왕(王)자형: 골격 돌출 + 볼 꺼짐. 자수성가 노력형, 재물 모으기엔 기복 가능."

        if (asymmetry_z > self.S["asymmetry_z"]) or (asymmetry_y > self.S["asymmetry_y"]):
            res = "쓸 용(用)자형: 비대칭/기울어진 상. 파란이 있으나 재기력 강, 수양 필요."

        self._append(report, f"▶ 최종 판정: {res}")

    # =============================================
    #                     눈썹
    # =============================================

    def analyze_brow(self, landmarks, report):
        metrics = self.calculate_brow_metrics(landmarks)
        res_type, res_desc = self.determine_book_type(metrics)

        self._append(report, "\n" + "=" * 60)
        self._append(report, "📖 [눈썹 관상학 분석]")
        self._append(report, "=" * 60)
        self._append(report, f"▶ 판정: {res_type}")
        self._append(report, f"▶ 해설: {res_desc}")

    # =============================================
    #                      눈
    # =============================================

    def analyze_eye(self, landmarks, report):
        metrics2 = self.calculate_eye_metrics(landmarks)
        eye_type, eye_desc = self.determine_book_type2(metrics2)

        self._append(report, "\n" + "=" * 60)
        self._append(report, "👁️ [눈 관상학 분석]")
        self._append(report, "=" * 60)
        self._append(report, f"▶ 판정: {eye_type}")
        self._append(report, f"▶ 해설: {eye_desc}")

    # =============================================
    #                      코
    # =============================================

    def analyze_nose(self, landmarks, w, h, report):
        metrics3 = self.calculate_nose_metrics(landmarks, w, h)
        nose_type, nose_desc = self.determine_nose_type(metrics3)

        self._append(report, "\n" + "=" * 60)
        self._append(report, "👃 [코 관상학 분석]")
        self._append(report, "=" * 60)
        self._append(report, f"▶ 판정: {nose_type}")
        self._append(report, f"▶ 해설: {nose_desc}")

    # =============================================
    #                      입
    # =============================================

    def analyze_mouth(self, landmarks, w, h, report):
        metrics4 = self.calculate_mouth_metrics(landmarks, w, h)
        mouth_type, mouth_desc = self.determine_mouth_type(metrics4)

        self._append(report, "\n" + "=" * 60)
        self._append(report, "👄 [입 관상학 분석]")
        self._append(report, "=" * 60)
        self._append(report, f"▶ 판정: {mouth_type}")
        self._append(report, f"▶ 해설: {mouth_desc}")

    # ============== 메인 파이프라인 ==============
    def process_combined(self, image_path):
        # 1) 이미지 로드 & 전처리
        img_pil = Image.open(image_path).convert('RGB')
        img = ImageOps.exif_transpose(img_pil)
        img_np = np.array(img)
        h, w, _ = img_np.shape

        img_bgr = cv2.cvtColor(img_np, cv2.COLOR_RGB2BGR)
        temp_mp_image = mp.Image(image_format=mp.ImageFormat.SRGB, data=img_np)
        temp_results = self.detector.detect(temp_mp_image)
        if not temp_results.face_landmarks:
            print("❌ 얼굴 인식 실패")
            return

        # 정렬

        img_bgr_aligned, rot_angle = self.align_face(img_bgr, temp_results)
        print(f"✔️ 얼굴 수직 정렬 완료 (회전 각도: {rot_angle:.2f}도)")

        img_rgb_aligned = cv2.cvtColor(img_bgr_aligned, cv2.COLOR_BGR2RGB)

        # Segface

        img_pil_aligned = Image.fromarray(img_rgb_aligned)
        img_seg = img_pil_aligned.resize((512,512))
        img_seg_np = np.array(img_seg)

        # SegFace 피부 추출
        input_tensor = torch.from_numpy(img_seg_np).permute(2,0,1).unsqueeze(0).float()/255.0
        with torch.no_grad():
            output = self.model(input_tensor.to(self.device), None, None)
            logits = output[-1] if isinstance(output, (list, tuple)) else output
            mask = torch.argmax(logits, dim=1).squeeze().cpu().numpy()

        skin_indices = np.where(mask == self.L_SKIN)
        seg_hairline_y_512 = np.min(skin_indices[0]) if len(skin_indices[0]) > 0 else None

        # hairline 원본 크기로 scaling
        if seg_hairline_y_512 is not None:
            seg_hairline_y = int(seg_hairline_y_512 * (h / 512))
        else:
            seg_hairline_y = None

        # MediaPipe
        mp_image = mp.Image(image_format = mp.ImageFormat.SRGB, data = img_rgb_aligned)
        results = self.detector.detect(mp_image)

        lm_data = results.face_landmarks[0]
        z = np.array([l.z for l in lm_data], dtype = np.float32)

        report = []

        # 4) 공통 얼굴형 메트릭
        face_info = self.calculate_face_shape_metrics(lm_data, z, w, h)
        pts = face_info["pts"]

        # 5) 삼정 분석
        self.analyze_samjeong(seg_hairline_y, pts, report)


        # 6) 얼굴형 분석
        self.analyze_face_shape(face_info, report)

        # 7) 오관별 분석
        self.analyze_brow(lm_data, report)
        self.analyze_eye(lm_data, report)
        self.analyze_nose(lm_data, w, h, report)
        self.analyze_mouth(lm_data, w, h, report)

    # ===================================================================
    # [ 시각화: 코멘트한 그대로 주요 라인만 그려 넣기 ]
    # ===================================================================
        W, H = img_bgr.shape[1], img_bgr.shape[0]
        actual_top_y = seg_hairline_y if seg_hairline_y is not None else pts[10][1]
    # 1) 삼정 라인 (상정·하정·이마~턱)
        cv2.line(img_bgr, (0, int(actual_top_y)), (W, int(actual_top_y)), (255,255,0), 2)  # 상정 시작 (연두 계열)
        cv2.line(img_bgr, (0, pts[9][1]),      (W, pts[9][1]),           (0,0,255), 1)    # 눈썹 라인
        cv2.line(img_bgr, (0, pts[2][1]),      (W, pts[2][1]),           (0,0,255), 1)    # 코끝
        cv2.line(img_bgr, (0, pts[152][1]),    (W, pts[152][1]),         (0,0,255), 1)    # 턱끝

    # 2) 눈썹선
        for i in [334, 105, 285, 300, 55, 70]:
            cv2.circle(img_bgr, tuple(pts[i]), 2, (255,0,255), -1)      # 각 눈썹 포인트
    # 눈썹 주요 라인: 왼쪽·오른쪽
        cv2.line(img_bgr, tuple(pts[285]), tuple(pts[300]), (255,0,255), 1)
        cv2.line(img_bgr, tuple(pts[55]),  tuple(pts[70]),  (255,0,255), 1)

    # 3) 눈 꼬리선
        cv2.line(img_bgr, pts[33], pts[133], (0,255,255), 1)
        cv2.line(img_bgr, pts[362], pts[263], (0,255,255), 1)

    # 4) 얼굴 기본 윤곽 (눈으로 대략 윤곽이 보일 정도만)
        for idx in self.FACE_OUTLINE:
            cv2.circle(img_bgr, tuple(pts[idx]), 1, (255,255,255), -1)

    # 5) 코·입 포인트
        for idx in [102,331,168,1,55,285]:   # 코 너비, 코끝, 산근, 미간 쪽 등
            cv2.circle(img_bgr, tuple(pts[idx]), 1, (0,255,0), -1)

        for idx in [61,291,0,17,13,14]:      # 입 왼·오 안쪽/바깥 입술
            cv2.circle(img_bgr, tuple(pts[idx]), 1, (0,255,0), -1)

    # 6) 턱 특징 포인트 (용/다이아 강조용)
        cv2.circle(img_bgr, tuple(pts[self.JAW_LEFT]),     2, (0,0,255), -1)
        cv2.circle(img_bgr, tuple(pts[self.JAW_RIGHT]),    2, (0,0,255), -1)
        cv2.circle(img_bgr, tuple(pts[self.JAW_L_CORNER]), 2, (255,0,0), -1)
        cv2.circle(img_bgr, tuple(pts[self.JAW_R_CORNER]), 2, (255,0,0), -1)
        cv2.circle(img_bgr, tuple(pts[self.CHIN]),         2, (0,0,255), -1)
        cv2.circle(img_bgr, tuple(pts[self.CHIN_L]),       1, (255,255,0), -1)
        cv2.circle(img_bgr, tuple(pts[self.CHIN_R]),       1, (255,255,0), -1)


    # Colab용: 화면에 보여주기
        cv2_imshow(img_bgr)
        # 8) 결과 출력
        for r in report:
            print(r)


# 사용 예시
analyzer = ComprehensiveFaceFortuneAI(model, device)
analyzer.process_combined('/content/fixed_image_temp.jpg')

# # ============================================================
# # 여러 사진 배치 관상 분석 (process_combined 사용)
# # ============================================================

# import os
# from glob import glob
# from datetime import datetime

# def batch_face_analysis(image_folder=".", output_folder="batch_results"):
#     """
#     여러 얼굴 사진을 한 번에 분석

#     Args:
#         image_folder: 분석할 이미지가 있는 폴더 경로 (기본값: 현재 폴더)
#         output_folder: 결과를 저장할 폴더 경로
#     """

#     # 출력 폴더 생성
#     os.makedirs(output_folder, exist_ok=True)

#     # 지원 이미지 확장자
#     extensions = ['*.jpg', '*.jpeg', '*.png', '*.JPG', '*.JPEG', '*.PNG']

#     # 모든 이미지 파일 찾기
#     image_files = []
#     for ext in extensions:
#         image_files.extend(glob(os.path.join(image_folder, ext)))

#     if not image_files:
#         print(f"❌ {image_folder}에서 이미지를 찾을 수 없습니다!")
#         return []

#     print(f"📁 총 {len(image_files)}개 이미지 발견!")
#     print("="*60)

#     # 결과 요약 리스트
#     results_summary = []

#     # 각 이미지 처리
#     for idx, img_path in enumerate(image_files, 1):
#         filename = os.path.basename(img_path)
#         print(f"\n[{idx}/{len(image_files)}] 처리 중: {filename}")
#         print("-"*60)

#         try:
#             # process_combined 실행
#             result = analyzer.process_combined(img_path)

#             if result:
#                 # 결과가 리스트로 반환되는 경우
#                 output_txt = os.path.join(output_folder, f"{os.path.splitext(filename)[0]}_report.txt")

#                 # 결과 저장
#                 with open(output_txt, 'w', encoding='utf-8') as f:
#                     if isinstance(result, list):
#                         f.write('\n'.join(result))
#                     else:
#                         f.write(str(result))

#                 results_summary.append({
#                     'filename': filename,
#                     'status': 'SUCCESS',
#                     'report_path': output_txt
#                 })

#                 print(f"✅ {filename}: 분석 완료!")
#                 print(f"   → 결과 저장: {output_txt}")
#             else:
#                 print(f"⚠️ {filename}: 결과 없음")
#                 results_summary.append({
#                     'filename': filename,
#                     'status': 'FAILED',
#                     'error': '결과 없음'
#                 })

#         except Exception as e:
#             print(f"❌ {filename}: 오류 발생!")
#             print(f"   → 오류 내용: {str(e)}")
#             results_summary.append({
#                 'filename': filename,
#                 'status': 'ERROR',
#                 'error': str(e)
#             })

#     # 전체 요약 리포트 생성
#     print("\n" + "="*60)
#     print("📊 배치 분석 결과 요약")
#     print("="*60)

#     success_count = sum(1 for r in results_summary if r['status'] == 'SUCCESS')
#     fail_count = len(results_summary) - success_count

#     print(f"✅ 성공: {success_count}개")
#     print(f"❌ 실패: {fail_count}개")
#     print(f"📁 결과 폴더: {output_folder}")

#     # 요약 파일 저장
#     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
#     summary_file = os.path.join(output_folder, f"batch_summary_{timestamp}.txt")

#     with open(summary_file, 'w', encoding='utf-8') as f:
#         f.write("="*60 + "\n")
#         f.write("배치 관상 분석 요약 리포트\n")
#         f.write(f"생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
#         f.write("="*60 + "\n\n")
#         f.write(f"총 처리: {len(results_summary)}개\n")
#         f.write(f"성공: {success_count}개\n")
#         f.write(f"실패: {fail_count}개\n")
#         f.write("\n" + "="*60 + "\n")
#         f.write("개별 결과\n")
#         f.write("="*60 + "\n\n")

#         for r in results_summary:
#             f.write(f"파일: {r['filename']}\n")
#             f.write(f"상태: {r['status']}\n")
#             if r['status'] == 'SUCCESS':
#                 f.write(f"리포트: {r['report_path']}\n")
#             elif 'error' in r:
#                 f.write(f"오류: {r['error']}\n")
#             f.write("\n" + "-"*60 + "\n\n")

#     print(f"📄 요약 파일 저장: {summary_file}")
#     print("\n✨ 모든 분석 완료!")

#     return results_summary


# # ============================================================
# # 실행
# # ============================================================

# # 현재 폴더의 모든 이미지 분석
# results = batch_face_analysis("/content/", "batch_results")

